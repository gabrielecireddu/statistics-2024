<!DOCTYPE html>
<html>
<head>
<style>
#container {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-content: center;
}
#graphCanvas {
    border: 1px solid black;
    border-radius: 10px;
    width: 1100px;
    height: 600px;
}

/* Media query per schermi medi */
@media (max-width: 1200px) {
    #graphCanvas {
        width: 1000px;
        height: 550px;
    }
}
/* Media query per schermi piccoli */
@media (max-width: 992px) {
    #graphCanvas {
        width: 800px;
        height: 450px;
    }
}
/* Media query per dispositivi mobili */
@media (max-width: 768px) {
    #graphCanvas {
        width: 600px;
        height: 400px;
    }
}
.input{
    width: 80px;
    border-radius: 10px;
}

.radioButton{
    margin-bottom: 15px;
}

</style>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>
<body style="background-color:antiquewhite;">
<div class="text-center">
    <br>
<div class="row" style="width: 100%;">
    <h1>SDE Simulator</h1>
    <div class="col-lg-3 col-12">
        <label>
            <input id="butt1" class="radioButton" type="radio" name="simulation" onclick="setSimulation(1)"checked><strong> Bernoulli Process</strong>
        </label>
    </div>
    <div class="col-lg-3 col-12">
        <label>
            <input id="butt2" class="radioButton" type="radio" name="simulation" onclick="setSimulation(2)"><strong> Random Walk</strong>
        </label>
    </div>
    <div class="col-lg-3 col-12">
        <label>
            <input id="butt3" class="radioButton" type="radio" name="simulation" onclick="setSimulation(3)"><strong> Proability = lambda*dt</strong>
        </label>
    </div>
    <div class="col-lg-3 col-12">
        <label>
            <input id="butt4" class="radioButton" type="radio" name="simulation" onclick="setSimulation(4)"><strong> Scaling limit of Random Walk</strong>
        </label>
    </div>

    <div class="col-lg-3 col-6" style="padding-bottom: 20px;">
        <label for="numHackers"><strong>#routes: </strong></label>
        <input class="input" type="number" id="numHackers" value="200">
    </div>
    <div class="col-lg-3 col-6" style="padding-bottom: 20px;">
        <label for="numIntervals"><strong>#intervals: </strong></label>
        <input class="input" type="number" id="numIntervals" value="200">
    </div>
    <div class="col-lg-2 col-12" style="padding-bottom: 20px;">
        <label id="probabilityLabel" for="probability"><strong>probability: </strong></label>
        <input class="input prob" type="number" id="probability" step="0.1" value="0.5">
    </div>
    <div class="col-lg-2 col-6" style="padding-bottom: 20px;">
        <label for="relPoint"><strong>relative point: </strong></label>
        <input class="input" type="number" id="relPoint" value="100">
    </div>
    <div class="col-lg-2 col-6" style="padding-bottom: 20px;">
        <button id="runButton" type="button" class="btn btn-success" onclick="runSimulation1()">Run Simulation</button>
    </div>
</div>
</div>
<div id="container">
<canvas id="graphCanvas"></canvas>
</div>
<script>
function setSimulation(simulationNumber) {
    const runButton = document.getElementById("runButton");
    switch (simulationNumber) {
        case 1:
            runButton.onclick = runSimulation1;
            switchLabel0()
            break;
        case 2:
            runButton.onclick = runSimulation2;
            switchLabel0()
            break;
        case 3:
            runButton.onclick = runSimulation3;
            switchLabel();
            break;
        case 4:
            runButton.onclick = runSimulation4;
            switchLabel0()
            break;
    }
}

function switchLabel(){
const label = document.getElementById("probabilityLabel");
label.innerHTML = "<strong>lambda: </strong>";
}

function switchLabel0(){
const label = document.getElementById("probabilityLabel");
label.innerHTML = "<strong>probability: </strong>";
}


function runSimulation1() {
    // Input values
    var n = parseInt(document.getElementById('numHackers').value);
    var m = parseInt(document.getElementById('numIntervals').value); // Number of intervals set by user
    var p = parseFloat(document.getElementById('probability').value);
    var r = parseInt(document.getElementById('relPoint').value);
    if (r > m) r = m;

    // Canvas for the main graph
    var canvas = document.getElementById('graphCanvas');
    var ctx = canvas.getContext('2d');

    // Set canvas dimensions
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Margins
    var marginLeft = 50;
    var marginRight = 200; // Reserve space for the final histogram
    var marginTop = 50;
    var marginBottom = 50;

    var plotWidth = canvas.width - marginLeft - marginRight;
    var plotHeight = canvas.height - marginTop - marginBottom;

    // Calculate xStep
    var xStep = plotWidth / m;

    // Adjust text size if necessary
    ctx.font = '12px Arial';
    if (xStep < 20) {
        ctx.font = '10px Arial';
    }
    if (xStep < 10) {
        ctx.font = '8px Arial';
    }

    // Estimate max possible level
    var maxPossibleLevel = Math.floor(m * (p + 0.2));

    var yStep = plotHeight / (maxPossibleLevel + 1);

    // Draw the x-axis on the main graph
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop + plotHeight);
    ctx.lineTo(marginLeft + plotWidth, marginTop + plotHeight);
    ctx.stroke();

    // Draw labels on the x-axis
    var x = marginLeft + m * xStep;
    ctx.beginPath();
    ctx.moveTo(x, marginTop + plotHeight - 5);
    ctx.lineTo(x, marginTop + plotHeight + 5);
    ctx.stroke();
    ctx.fillText(m, x, marginTop + plotHeight + 20);

    // Draw a vertical line at point r
    var xAtR = marginLeft + r * xStep;
    ctx.strokeStyle = 'red';
    ctx.beginPath();
    ctx.moveTo(xAtR, marginTop);
    ctx.lineTo(xAtR, marginTop + plotHeight);
    ctx.stroke();
    ctx.strokeStyle = 'black';

    // Generate different colors for each hacker
    var colors = [];
    for (var i = 0; i < n; i++) {
        colors.push('hsl(' + (i * 360 / n) + ', 100%, 50%)');
    }

    // Arrays to store levels reached
    var levelsReached = [];
    var relativeLevelsReached = [];

    // Variables for mean and variance
    var mean = 0;
    var delta = 0;
    var deviance = 0;

    var meanAtR = 0;
    var deltaAtR = 0;
    var devianceAtR = 0;

    var maxLevelReached = 0;

    // Simulation for each hacker
    for (var h = 0; h < n; h++) {
        var x = marginLeft; // Initial x position
        var y = marginTop + plotHeight; // Start at the bottom
        var level = 0; // Initial level
        ctx.strokeStyle = colors[h];
        ctx.beginPath();
        ctx.moveTo(x, y);

        var levelAtR = 0; // Level at point r

        for (var s = 1; s <= m; s++) {
            // Move horizontally to the next server
            x += xStep;

            ctx.lineTo(x, y);

            var rand = Math.random();
            if (rand <= p) {
                // Success, move up
                y -= yStep; // Move up yStep pixels
                level++; // Increment level
            }

            ctx.lineTo(x, y);

            if (level > maxLevelReached){
                maxLevelReached = level;
            }

            // Store the level at point r
            if (s === r) {
                levelAtR = level;
                relativeLevelsReached.push(levelAtR);
            }
        }
        ctx.stroke();

        // Add the final level to the array
        levelsReached.push(level);

        // Calculate mean and variance
        var k = h + 1; // Current index (from 1 to n)
        delta = (level - mean);
        mean += delta / k;
        deviance += (level - mean) * delta;

        deltaAtR = (levelAtR - meanAtR);
        meanAtR += deltaAtR / k;
        devianceAtR += (levelAtR - meanAtR) * deltaAtR;
    }

    // Draw the final histogram
    var xStartFinalHistogram = marginLeft + plotWidth;
    var histogramWidth = marginRight - 20;
    drawAlignedHistogram1(ctx, levelsReached, n, maxPossibleLevel, yStep, xStartFinalHistogram, marginTop, histogramWidth, plotHeight);

    // Draw the histogram at point r within the main graph
    var histogramWidthAtR = 0.15 * plotWidth; // For example, 15% of the graph width
    drawAlignedHistogramAtR1(ctx, relativeLevelsReached, n, maxPossibleLevel, yStep, xAtR + 5, marginTop, histogramWidthAtR, plotHeight);

    // Display mean and variance on the graph
    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Total Mean: ' + mean.toFixed(2), marginLeft + plotWidth + 20, marginTop - 30);
    var variance = deviance / n;
    ctx.fillText('Total Variance: ' + variance.toFixed(2), marginLeft + plotWidth + 20, marginTop - 15);

    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Relative Mean: ' + meanAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 15);
    var varianceAtR = devianceAtR / n;
    ctx.fillText('Relative Variance: ' + varianceAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 30);

    ctx.fillText('Max Level Reached: ' + maxLevelReached, marginLeft + plotWidth + 20, marginTop);
}

function drawAlignedHistogram1(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight) {
    // Calculate the frequency of each level
    var frequency = {};
    for (var i = 0; i <= maxLevel; i++) {
        frequency[i] = 0;
    }
    data.forEach(function(level) {
        frequency[level]++;
    });

    // Height of the bars aligned with yStep
    var barHeight = yStep - 2;

    // Find the maximum frequency for scaling
    var maxFrequency = Math.max(...Object.values(frequency));

    // Adjust text size if necessary
    ctx.font = '12px Arial';
    if (barHeight < 20) {
        ctx.font = '10px Arial';
    }
    if (barHeight < 10) {
        ctx.font = '8px Arial';
    }

    // Draw the histogram bars aligned to the levels
    ctx.fillStyle = 'skyblue';
    ctx.strokeStyle = 'black';

    for (var i = maxLevel; i >= 0; i--) {
        var y = yStart + plotHeight - (i * yStep) - yStep + 1;
        var barLength = (frequency[i] / maxFrequency) * histogramWidth;
        var x = xStart + 10; // Small left margin

        // Draw the bar only if at least one hacker reached that level
        if (frequency[i] > 0) {
            ctx.fillRect(x, y, barLength, barHeight);
            ctx.strokeRect(x, y, barLength, barHeight);
            ctx.fillStyle = 'skyblue';
        }
    }
}

function drawAlignedHistogramAtR1(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight) {
    // Calculate the frequency of each level
    var frequency = {};
    for (var i = 0; i <= maxLevel; i++) {
        frequency[i] = 0;
    }
    data.forEach(function(level) {
        frequency[level]++;
    });

    // Height of the bars aligned with yStep
    var barHeight = yStep - 2;

    // Find the maximum frequency for scaling
    var maxFrequency = Math.max(...Object.values(frequency));

    // Adjust text size if necessary
    ctx.font = '12px Arial';
    if (barHeight < 20) {
        ctx.font = '10px Arial';
    }
    if (barHeight < 10) {
        ctx.font = '8px Arial';
    }

    // Draw the histogram bars aligned to the levels
    ctx.fillStyle = 'red';
    ctx.strokeStyle = 'black';

    for (var i = maxLevel; i >= 0; i--) {
        var y = yStart + plotHeight - (i * yStep) - yStep + 1;
        var barLength = (frequency[i] / maxFrequency) * histogramWidth;
        var x = xStart; // Position the histogram at point r

        // Draw the bar only if at least one hacker reached that level
        if (frequency[i] > 0) {
            ctx.fillRect(x, y, barLength, barHeight);
            ctx.strokeRect(x, y, barLength, barHeight);
            ctx.fillStyle = 'red';
        }
    }
}

function runSimulation2() {
    // Input values
    var n = parseInt(document.getElementById('numHackers').value);
    var m = parseInt(document.getElementById('numIntervals').value);
    var p = parseFloat(document.getElementById('probability').value);
    var r = parseInt(document.getElementById('relPoint').value);

    // Canvas per il grafico principale
    var canvas = document.getElementById('graphCanvas');
    var ctx = canvas.getContext('2d');

    // Imposta le dimensioni del canvas
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Margini
    var marginLeft = 50;
    var marginRight = 200; // Riserva spazio per l'istogramma finale
    var marginTop = 50;
    var marginBottom = 50;

    var plotWidth = canvas.width - marginLeft - marginRight;
    var plotHeight = canvas.height - marginTop - marginBottom;

    // Calcola xStep
    var availableWidth = plotWidth;
    var minLabelSpacing = 20; // Spazio minimo tra le etichette
    var maxLabels = Math.floor(availableWidth / minLabelSpacing);

    var labelInterval = Math.ceil(m / maxLabels);
    var xStep = availableWidth / m;

    // Riduci la dimensione del testo se necessario
    ctx.font = '12px Arial';
    if (xStep < 20) {
        ctx.font = '10px Arial';
    }
    if (xStep < 10) {
        ctx.font = '8px Arial';
    }

    // Calcola yStep
    var maxPossibleLevel = m;
    var yStep = plotHeight / (2 * maxPossibleLevel + 1);

    // Disegna l'asse dei server sul grafico principale
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop + plotHeight); // Asse orizzontale al centro
    ctx.lineTo(marginLeft + plotWidth, marginTop + plotHeight);
    ctx.stroke();

    // Disegna le etichette dei server
    for (var i = 0; i <= m; i++) {
        var x = marginLeft + i * xStep;

        // Disegna tick
        if (i % labelInterval === 0 || i === m || i === r) {
            ctx.beginPath();
            ctx.moveTo(x, marginTop + plotHeight - 5);
            ctx.lineTo(x, marginTop + plotHeight + 5);
            ctx.stroke();
            ctx.fillText(i, x, marginTop + plotHeight + 20);
        }

        // Disegna una linea verticale nel punto r
        if (i === r) {
            ctx.strokeStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(x, marginTop);
            ctx.lineTo(x, marginTop + plotHeight);
            ctx.stroke();
            ctx.strokeStyle = 'black';
        }
    }

    // Genera colori differenti per ogni hacker
    var colors = [];
    for (var i = 0; i < n; i++) {
        colors.push('hsl(' + (i * 360 / n) + ', 100%, 50%)');
    }

    // Array per memorizzare i livelli raggiunti
    var levelsReached = [];
    var relativeLevelsReached = [];

    // Variabili per la media e la varianza
    var mean = 0;
    var delta = 0;
    var deviance = 0;

    var meanAtR = 0;
    var deltaAtR = 0;
    var devianceAtR = 0;

    var maxLevelReached = 0;
            var minLevelReached = 0;

    // Simulazione per ogni hacker
    for (var h = 0; h < n; h++) {
        var x = marginLeft; // Posizione x iniziale
        var y = marginTop + plotHeight / 2; // Posizione y iniziale (centro verticale)
        var level = 0; // Livello iniziale
        ctx.strokeStyle = colors[h];
        ctx.beginPath();
        ctx.moveTo(x, y);

        var levelAtR = 0; // Livello al punto r

        for (var s = 1; s <= m; s++) {
            // Muovi orizzontalmente al prossimo server
            x += xStep;
            ctx.lineTo(x, y);

            var rand = Math.random();
            if (rand <= p) {
                // Successo, muovi verso l'alto
                y -= yStep; // Muovi su di yStep pixel
                level++; // Incrementa il livello
            } else {
                // Fallimento, muovi verso il basso
                y += yStep; // Muovi giù di yStep pixel
                level--; // Decrementa il livello
            }

            // Memorizza il livello al punto r
            if (s === r) {
                levelAtR = level;
                relativeLevelsReached.push(levelAtR);
            }

            if (level > maxLevelReached){
                maxLevelReached = level;
            }
            if (level < minLevelReached){
                minLevelReached = level;
            }

            ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Aggiungi il livello finale all'array
        levelsReached.push(level);

        // Calcola la media e la varianza
        var k = h + 1; // Indice corrente (da 1 a n)
        delta = (level - mean);
        mean += delta / k;
        deviance += (level - mean) * delta;

        deltaAtR = (levelAtR - meanAtR);
        meanAtR += deltaAtR / k;
        devianceAtR += (levelAtR - meanAtR) * deltaAtR;
    }

    // Disegna l'istogramma finale
    var xStartFinalHistogram = marginLeft + plotWidth;
    var histogramWidth = marginRight - 20;
    drawAlignedHistogram2(ctx, levelsReached, n, m, yStep, xStartFinalHistogram, marginTop, histogramWidth, plotHeight);

    // Disegna l'istogramma al punto r all'interno del grafico principale
    var xAtR = marginLeft + r * xStep;
    var histogramWidthAtR = 0.25 * plotWidth; // Ad esempio, il 15% della larghezza del grafico
    drawAlignedHistogramAtR2(ctx, relativeLevelsReached, n, r, yStep, xAtR + 5, marginTop, histogramWidthAtR, plotHeight);

    // Mostra la media e la varianza sul grafico
    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Total Mean: ' + mean.toFixed(2), marginLeft + plotWidth + 20, marginTop - 30);
    var variance = deviance / n;
    ctx.fillText('Total Variance: ' + variance.toFixed(2), marginLeft + plotWidth + 20, marginTop - 15);

    ctx.fillText('Max Level Reached: ' + maxLevelReached, marginLeft + plotWidth + 20, marginTop);

    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Relative Mean: ' + meanAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 15);
    var varianceAtR = devianceAtR / n;
    ctx.fillText('Relative Variance: ' + varianceAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 30);

    ctx.fillText('Min Level Reached: ' + minLevelReached, marginLeft + plotWidth + 20, marginTop + plotHeight);
}

function drawAlignedHistogram2(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight) {
    // Calcola la frequenza di ogni livello
    var frequency = {};
    for (var i = -maxLevel; i <= maxLevel; i++) {
        frequency[i] = 0;
    }
    data.forEach(function(level) {
        frequency[level]++;
    });

    // Altezza delle barre allineata con yStep
    var barHeight = yStep - 2;

    // Trova la frequenza massima per il ridimensionamento
    var maxFrequency = Math.max(...Object.values(frequency));

    // Riduci la dimensione del testo se necessario
    ctx.font = '12px Arial';
    if (barHeight < 20) {
        ctx.font = '10px Arial';
    }
    if (barHeight < 10) {
        ctx.font = '8px Arial';
    }

    // Disegna le barre dell'istogramma allineate ai livelli
    ctx.fillStyle = 'skyblue';
    ctx.strokeStyle = 'black';

    for (var i = maxLevel; i >= -maxLevel; i--) {
        var y = yStart + plotHeight / 2 - (i * yStep) - yStep + 1;
        var barLength = (frequency[i] / maxFrequency) * histogramWidth;
        var x = xStart + 10; // Piccolo margine a sinistra

        // Disegna la barra solo se c'è almeno un hacker che ha raggiunto quel livello
        if (frequency[i] > 0) {
            ctx.fillRect(x, y, barLength, barHeight);
            ctx.strokeRect(x, y, barLength, barHeight);

            ctx.fillStyle = 'skyblue';
        }
    }
}

function drawAlignedHistogramAtR2(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight, title) {
    // Calcola la frequenza di ogni livello
    var frequency = {};
    for (var i = -maxLevel; i <= maxLevel; i++) {
        frequency[i] = 0;
    }
    data.forEach(function(level) {
        frequency[level]++;
    });

    // Altezza delle barre allineata con yStep
    var barHeight = yStep - 2;

    // Trova la frequenza massima per il ridimensionamento
    var maxFrequency = Math.max(...Object.values(frequency));

    // Riduci la dimensione del testo se necessario
    ctx.font = '12px Arial';
    if (barHeight < 20) {
        ctx.font = '10px Arial';
    }
    if (barHeight < 10) {
        ctx.font = '8px Arial';
    }

    // Disegna le barre dell'istogramma allineate ai livelli
    ctx.fillStyle = 'red';
    ctx.strokeStyle = 'black';

    for (var i = maxLevel; i >= -maxLevel; i--) {
        var y = yStart + plotHeight / 2 - (i * yStep) - yStep + 1;
        var barLength = (frequency[i] / maxFrequency) * histogramWidth;
        var x = xStart; // Posiziona l'istogramma al punto r

        // Disegna la barra solo se c'è almeno un hacker che ha raggiunto quel livello
        if (frequency[i] > 0) {
            ctx.fillRect(x, y, barLength, barHeight);
            ctx.strokeRect(x, y, barLength, barHeight);

            ctx.fillStyle = 'red';
        }
    }
}

function runSimulation3() {
// Input values
var n = parseInt(document.getElementById('numHackers').value);
var m = parseInt(document.getElementById('numIntervals').value); // Number of intervals set by user
var lambda = parseFloat(document.getElementById('probability').value);
var p = lambda / m;
var r = parseInt(document.getElementById('relPoint').value);
if (r > m) r = m;

// Canvas for the main graph
var canvas = document.getElementById('graphCanvas');
var ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;

// Clear the canvas
ctx.clearRect(0, 0, canvas.width, canvas.height);

// Margins
var marginLeft = 50;
var marginRight = 200; // Reserve space for the final histogram
var marginTop = 50;
var marginBottom = 50;

var plotWidth = canvas.width - marginLeft - marginRight;
var plotHeight = canvas.height - marginTop - marginBottom;

// Calculate xStep
var xStep = plotWidth / m;

// Adjust text size if necessary
ctx.font = '12px Arial';
if (xStep < 20) {
    ctx.font = '10px Arial';
}
if (xStep < 10) {
    ctx.font = '8px Arial';
}

// Estimate max possible level
var maxPossibleLevel = Math.ceil(lambda + 5 * Math.sqrt(lambda));
var yStep = plotHeight / (maxPossibleLevel + 1);

// Draw the x-axis on the main graph
ctx.beginPath();
ctx.moveTo(marginLeft, marginTop + plotHeight);
ctx.lineTo(marginLeft + plotWidth, marginTop + plotHeight);
ctx.stroke();

// Draw labels on the x-axis
var x = marginLeft + m * xStep;
ctx.beginPath();
ctx.moveTo(x, marginTop + plotHeight - 5);
ctx.lineTo(x, marginTop + plotHeight + 5);
ctx.stroke();
ctx.fillText(m, x, marginTop + plotHeight + 20);

// Draw a vertical line at point r
var xAtR = marginLeft + r * xStep;
ctx.strokeStyle = 'red';
ctx.beginPath();
ctx.moveTo(xAtR, marginTop);
ctx.lineTo(xAtR, marginTop + plotHeight);
ctx.stroke();
ctx.strokeStyle = 'black';

// Generate different colors for each hacker
var colors = [];
for (var i = 0; i < n; i++) {
    colors.push('hsl(' + (i * 360 / n) + ', 100%, 50%)');
}

// Arrays to store levels reached
var levelsReached = [];
var relativeLevelsReached = [];

// Variables for mean and variance
var mean = 0;
var delta = 0;
var deviance = 0;

var meanAtR = 0;
var deltaAtR = 0;
var devianceAtR = 0;

// Simulation for each hacker
for (var h = 0; h < n; h++) {
    var x = marginLeft; // Initial x position
    var y = marginTop + plotHeight; // Start at the bottom
    var level = 0; // Initial level
    ctx.strokeStyle = colors[h];
    ctx.beginPath();
    ctx.moveTo(x, y);

    var levelAtR = 0; // Level at point r

    for (var s = 1; s <= m; s++) {
        // Move horizontally to the next server
        x += xStep;

        ctx.lineTo(x, y);

        var rand = Math.random();
        if (rand <= p) {
            // Success, move up
            y -= yStep; // Move up yStep pixels
            level++; // Increment level
        }

        ctx.lineTo(x, y);

        // Store the level at point r
        if (s === r) {
            levelAtR = level;
            relativeLevelsReached.push(levelAtR);
        }
    }
    ctx.stroke();

    // Add the final level to the array
    levelsReached.push(level);

    // Calculate mean and variance
    var k = h + 1; // Current index (from 1 to n)
    delta = (level - mean);
    mean += delta / k;
    deviance += (level - mean) * delta;

    deltaAtR = (levelAtR - meanAtR);
    meanAtR += deltaAtR / k;
    devianceAtR += (levelAtR - meanAtR) * deltaAtR;
}

// Draw the final histogram
var xStartFinalHistogram = marginLeft + plotWidth;
var histogramWidth = marginRight - 20;
drawAlignedHistogram3(ctx, levelsReached, n, maxPossibleLevel, yStep, xStartFinalHistogram, marginTop, histogramWidth, plotHeight);

// Draw the histogram at point r within the main graph
var histogramWidthAtR = 0.15 * plotWidth; // For example, 15% of the graph width
drawAlignedHistogramAtR3(ctx, relativeLevelsReached, n, maxPossibleLevel, yStep, xAtR + 5, marginTop, histogramWidthAtR, plotHeight);

// Display mean and variance on the graph
ctx.fillStyle = 'black';
ctx.font = '16px Arial';
ctx.textAlign = 'left';
ctx.fillText('Total Mean: ' + mean.toFixed(2), marginLeft + plotWidth + 20, marginTop - 30);
var variance = deviance / n;
ctx.fillText('Total Variance: ' + variance.toFixed(2), marginLeft + plotWidth + 20, marginTop - 15);

ctx.fillStyle = 'black';
ctx.font = '16px Arial';
ctx.textAlign = 'left';
ctx.fillText('Relative Mean: ' + meanAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 15);
var varianceAtR = devianceAtR / n;
ctx.fillText('Relative Variance: ' + varianceAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 30);
}

function drawAlignedHistogram3(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight) {
// Calculate the frequency of each level
var frequency = {};
for (var i = 0; i <= maxLevel; i++) {
    frequency[i] = 0;
}
data.forEach(function(level) {
    frequency[level]++;
});

// Height of the bars aligned with yStep
var barHeight = yStep - 2;

// Find the maximum frequency for scaling
var maxFrequency = Math.max(...Object.values(frequency));

// Adjust text size if necessary
ctx.font = '12px Arial';
if (barHeight < 20) {
    ctx.font = '10px Arial';
}
if (barHeight < 10) {
    ctx.font = '8px Arial';
}

// Draw the histogram bars aligned to the levels
ctx.fillStyle = 'skyblue';
ctx.strokeStyle = 'black';

for (var i = maxLevel; i >= 0; i--) {
    var y = yStart + plotHeight - (i * yStep) - yStep + 1;
    var barLength = (frequency[i] / maxFrequency) * histogramWidth;
    var x = xStart + 10; // Small left margin

    // Draw the bar only if at least one hacker reached that level
    if (frequency[i] > 0) {
        ctx.fillRect(x, y, barLength, barHeight);
        ctx.strokeRect(x, y, barLength, barHeight);
        ctx.fillStyle = 'skyblue';
    }
}
}

function drawAlignedHistogramAtR3(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight) {
// Calculate the frequency of each level
var frequency = {};
for (var i = 0; i <= maxLevel; i++) {
    frequency[i] = 0;
}
data.forEach(function(level) {
    frequency[level]++;
});

// Height of the bars aligned with yStep
var barHeight = yStep - 2;

// Find the maximum frequency for scaling
var maxFrequency = Math.max(...Object.values(frequency));

// Adjust text size if necessary
ctx.font = '12px Arial';
if (barHeight < 20) {
    ctx.font = '10px Arial';
}
if (barHeight < 10) {
    ctx.font = '8px Arial';
}

// Draw the histogram bars aligned to the levels
ctx.fillStyle = 'red';
ctx.strokeStyle = 'black';

for (var i = maxLevel; i >= 0; i--) {
    var y = yStart + plotHeight - (i * yStep) - yStep + 1;
    var barLength = (frequency[i] / maxFrequency) * histogramWidth;
    var x = xStart; // Position the histogram at point r

    // Draw the bar only if at least one hacker reached that level
    if (frequency[i] > 0) {
        ctx.fillRect(x, y, barLength, barHeight);
        ctx.strokeRect(x, y, barLength, barHeight);
        ctx.fillStyle = 'red';
    }
}
}

function runSimulation4() {
            // Input values
            var n = parseInt(document.getElementById('numHackers').value);
            var m = parseInt(document.getElementById('numIntervals').value);
            var p = parseFloat(document.getElementById('probability').value);

            if (p>1) p=1;

            var r = parseInt(document.getElementById('relPoint').value);

            // Canvas per il grafico principale
            var canvas = document.getElementById('graphCanvas');
            var ctx = canvas.getContext('2d');

            // Imposta le dimensioni del canvas
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            // Pulisci il canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Margini
            var marginLeft = 50;
            var marginRight = 200; // Riserva spazio per l'istogramma finale
            var marginTop = 50;
            var marginBottom = 50;

            var plotWidth = canvas.width - marginLeft - marginRight;
            var plotHeight = canvas.height - marginTop - marginBottom;

            // Calcola xStep
            var availableWidth = plotWidth;
            var minLabelSpacing = 20; // Spazio minimo tra le etichette
            var maxLabels = Math.floor(availableWidth / minLabelSpacing);

            var labelInterval = Math.ceil(m / maxLabels);
            var xStep = availableWidth / m;

            // Riduci la dimensione del testo se necessario
            ctx.font = '12px Arial';
            if (xStep < 20) {
                ctx.font = '10px Arial';
            }
            if (xStep < 10) {
                ctx.font = '8px Arial';
            }

            // Calcola yStep
            if ( m <= 500) {
                var maxPossibleLevel = Math.floor(m/10);
            } else if (p == 0.3 || p == 0.7){
                var maxPossibleLevel = Math.floor(m / 17); // Livello massimo possibile (positivo o negativo)
            } else if (p == 0.2 || p == 0.8){
                var maxPossibleLevel = Math.floor(m / 13);
            }else if (p == 0.1 || p == 0.9){
                var maxPossibleLevel = Math.floor(m / 11);
            }else if (p == 0 || p == 1){
                var maxPossibleLevel = Math.floor(m / 10);
            }else if (p == 0.4 || p == 0.6){
                var maxPossibleLevel = Math.floor(m / 25);
            }
            else {
                var maxPossibleLevel = Math.floor(m / 40);
            }
            var yStep = (plotHeight / (2 * maxPossibleLevel + 1)) * (1 / Math.sqrt(maxPossibleLevel + 1));

            // Disegna l'asse dei server sul grafico principale
            ctx.beginPath();
            ctx.moveTo(marginLeft, marginTop + plotHeight); // Asse orizzontale al centro
            ctx.lineTo(marginLeft + plotWidth, marginTop + plotHeight);
            ctx.stroke();

            // Disegna le etichette dei server
            for (var i = 0; i <= m; i++) {
                var x = marginLeft + i * xStep;

                // Disegna tick
                if (i % labelInterval === 0 || i === m || i === r) {
                    ctx.beginPath();
                    ctx.moveTo(x, marginTop + plotHeight - 5);
                    ctx.lineTo(x, marginTop + plotHeight + 5);
                    ctx.stroke();
                    ctx.fillText(i, x, marginTop + plotHeight + 20);
                }

                // Disegna una linea verticale nel punto r
                if (i === r) {
                    ctx.strokeStyle = 'red';
                    ctx.beginPath();
                    ctx.moveTo(x, marginTop);
                    ctx.lineTo(x, marginTop + plotHeight);
                    ctx.stroke();
                    ctx.strokeStyle = 'black';
                }
            }

            // Genera colori differenti per ogni hacker
            var colors = [];
            for (var i = 0; i < n; i++) {
                colors.push('hsl(' + (i * 360 / n) + ', 100%, 50%)');
            }

            // Array per memorizzare i livelli raggiunti
            var levelsReached = [];
            var relativeLevelsReached = [];

            // Variabili per la media e la varianza
            var mean = 0;
            var delta = 0;
            var deviance = 0;

            var meanAtR = 0;
            var deltaAtR = 0;
            var devianceAtR = 0;

            var maxLevelReached = 0;
            var minLevelReached = 0;

            // Simulazione per ogni hacker
            for (var h = 0; h < n; h++) {
                var x = marginLeft; // Posizione x iniziale
                var y = marginTop + plotHeight / 2; // Posizione y iniziale (centro verticale)
                var level = 0; // Livello iniziale
                ctx.strokeStyle = colors[h];
                ctx.beginPath();
                ctx.moveTo(x, y);

                var levelAtR = 0; // Livello al punto r

                for (var s = 1; s <= m; s++) {
                    // Muovi orizzontalmente al prossimo server
                    x += xStep;
                    ctx.lineTo(x, y);

                    var rand = Math.random();
                    if (rand <= p) {
                        // Successo, muovi verso l'alto
                        y -= yStep; // Muovi su di yStep pixel
                        level++; // Incrementa il livello
                    } else {
                        // Fallimento, muovi verso il basso
                        y += yStep; // Muovi giù di yStep pixel
                        level--; // Decrementa il livello
                    }

                    // Memorizza il livello al punto r
                    if (s === r) {
                        levelAtR = level;
                        relativeLevelsReached.push(levelAtR);
                    }

                    if (level > maxLevelReached){
                        maxLevelReached = level;
                    }
                    if (level < minLevelReached){
                        minLevelReached = level;
                    }

                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Aggiungi il livello finale all'array
                levelsReached.push(level);

                // Calcola la media e la varianza
                var k = h + 1; // Indice corrente (da 1 a n)
                delta = (level - mean);
                mean += delta / k;
                deviance += (level - mean) * delta;

                deltaAtR = (levelAtR - meanAtR);
                meanAtR += deltaAtR / k;
                devianceAtR += (levelAtR - meanAtR) * deltaAtR;
            }

            // Disegna l'istogramma finale
            var xStartFinalHistogram = marginLeft + plotWidth;
            var histogramWidth = marginRight - 20;
            drawAlignedHistogram4(ctx, levelsReached, n, m, yStep, xStartFinalHistogram, marginTop, histogramWidth, plotHeight);

            // Disegna l'istogramma al punto r all'interno del grafico principale
            var xAtR = marginLeft + r * xStep;
            var histogramWidthAtR = 0.25 * plotWidth; // Ad esempio, il 15% della larghezza del grafico
            drawAlignedHistogramAtR4(ctx, relativeLevelsReached, n, r, yStep, xAtR + 5, marginTop, histogramWidthAtR, plotHeight);

            // Mostra la media e la varianza sul grafico
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Total Mean: ' + mean.toFixed(2), marginLeft + plotWidth + 20, marginTop - 30);
            var variance = deviance / n;
            ctx.fillText('Total Variance: ' + variance.toFixed(2), marginLeft + plotWidth + 20, marginTop - 15);

            ctx.fillText('Max Level Reached: ' + maxLevelReached, marginLeft + plotWidth + 20, marginTop);

            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Relative Mean: ' + meanAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 15);
            var varianceAtR = devianceAtR / n;
            ctx.fillText('Relative Variance: ' + varianceAtR.toFixed(2), marginLeft + plotWidth + 20, marginTop + plotHeight + 30);

            ctx.fillText('Min Level Reached: ' + minLevelReached, marginLeft + plotWidth + 20, marginTop + plotHeight);
        }

        function drawAlignedHistogram4(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight) {
            // Calcola la frequenza di ogni livello
            var frequency = {};
            for (var i = -maxLevel; i <= maxLevel; i++) {
                frequency[i] = 0;
            }
            data.forEach(function(level) {
                frequency[level]++;
            });

            // Altezza delle barre allineata con yStep
            var barHeight = yStep - 2;

            // Trova la frequenza massima per il ridimensionamento
            var maxFrequency = Math.max(...Object.values(frequency));

            // Riduci la dimensione del testo se necessario
            ctx.font = '12px Arial';
            if (barHeight < 20) {
                ctx.font = '10px Arial';
            }
            if (barHeight < 10) {
                ctx.font = '8px Arial';
            }

            // Disegna le barre dell'istogramma allineate ai livelli
            ctx.fillStyle = 'skyblue';
            ctx.strokeStyle = 'black';

            for (var i = maxLevel; i >= -maxLevel; i--) {
                var y = yStart + plotHeight / 2 - (i * yStep) - yStep + 1;
                var barLength = (frequency[i] / maxFrequency) * histogramWidth;
                var x = xStart + 10; // Piccolo margine a sinistra

                // Disegna la barra solo se c'è almeno un hacker che ha raggiunto quel livello
                if (frequency[i] > 0) {
                    ctx.fillRect(x, y, barLength, barHeight);
                    ctx.strokeRect(x, y, barLength, barHeight);

                    ctx.fillStyle = 'skyblue';
                }
            }
        }

        function drawAlignedHistogramAtR4(ctx, data, totalHackers, maxLevel, yStep, xStart, yStart, histogramWidth, plotHeight, title) {
            // Calcola la frequenza di ogni livello
            var frequency = {};
            for (var i = -maxLevel; i <= maxLevel; i++) {
                frequency[i] = 0;
            }
            data.forEach(function(level) {
                frequency[level]++;
            });

            // Altezza delle barre allineata con yStep
            var barHeight = yStep - 2;

            // Trova la frequenza massima per il ridimensionamento
            var maxFrequency = Math.max(...Object.values(frequency));

            // Riduci la dimensione del testo se necessario
            ctx.font = '12px Arial';
            if (barHeight < 20) {
                ctx.font = '10px Arial';
            }
            if (barHeight < 10) {
                ctx.font = '8px Arial';
            }

            // Disegna le barre dell'istogramma allineate ai livelli
            ctx.fillStyle = 'red';
            ctx.strokeStyle = 'black';

            for (var i = maxLevel; i >= -maxLevel; i--) {
                var y = yStart + plotHeight / 2 - (i * yStep) - yStep + 1;
                var barLength = (frequency[i] / maxFrequency) * histogramWidth;
                var x = xStart; // Posiziona l'istogramma al punto r

                // Disegna la barra solo se c'è almeno un hacker che ha raggiunto quel livello
                if (frequency[i] > 0) {
                    ctx.fillRect(x, y, barLength, barHeight);
                    ctx.strokeRect(x, y, barLength, barHeight);

                    ctx.fillStyle = 'red';
                }
            }
        }
</script>
</body>
</html>
